// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: et_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// user management module
struct LoginWithGoogle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var idToken: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var success: Bool = false

    var userID: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct LoginDashboard {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var email: String = String()

    var name: String = String()

    var dashboardKey: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var success: Bool = false

    var userID: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct BindUserToCampaign {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var userID: Int32 = 0

    var email: String = String()

    var campaignID: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var success: Bool = false

    var isFirstTimeBinding: Bool = false

    var campaignStartTimestamp: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct RetrieveParticipants {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var userID: Int32 = 0

    var email: String = String()

    var campaignID: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var success: Bool = false

    var userID: [Int32] = []

    var email: [String] = []

    var name: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct RetrieveParticipantStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var userID: Int32 = 0

    var email: String = String()

    var targetEmail: String = String()

    var targetCampaignID: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var success: Bool = false

    var activeCampaignID: Int32 = 0

    var campaignJoinTimestamp: Int64 = 0

    var lastSyncTimestamp: Int64 = 0

    var lastHeartbeatTimestamp: Int64 = 0

    var amountOfSubmittedDataSamples: Int32 = 0

    var dataSourceID: [Int32] = []

    var perDataSourceAmountOfData: [Int32] = []

    var perDataSourceLastSyncTimestamp: [Int64] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// campaign management module
struct RegisterCampaign {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var userID: Int32 = 0

    var email: String = String()

    var campaignID: Int32 = 0

    var name: String = String()

    var notes: String = String()

    var configJson: String = String()

    var startTimestamp: Int64 = 0

    var endTimestamp: Int64 = 0

    var removeInactiveUsersTimeout: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var success: Bool = false

    var campaignID: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct DeleteCampaign {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var userID: Int32 = 0

    var email: String = String()

    var campaignID: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var success: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct RetrieveCampaigns {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var userID: Int32 = 0

    var email: String = String()

    var myCampaignsOnly: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var success: Bool = false

    var campaignID: [Int32] = []

    var name: [String] = []

    var notes: [String] = []

    var startTimestamp: [Int64] = []

    var endTimestamp: [Int64] = []

    var removeInactiveUsersTimeout: [Int32] = []

    var creatorEmail: [String] = []

    var configJson: [String] = []

    var participantCount: [Int32] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct RetrieveCampaign {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var userID: Int32 = 0

    var email: String = String()

    var campaignID: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var success: Bool = false

    var name: String = String()

    var notes: String = String()

    var startTimestamp: Int64 = 0

    var endTimestamp: Int64 = 0

    var creatorEmail: String = String()

    var configJson: String = String()

    var participantCount: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// data source management module
struct BindDataSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var userID: Int32 = 0

    var email: String = String()

    var name: String = String()

    var iconName: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var success: Bool = false

    var dataSourceID: Int32 = 0

    var iconName: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct RetrieveDataSources {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var userID: Int32 = 0

    var email: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var success: Bool = false

    var dataSourceID: [Int32] = []

    var name: [String] = []

    var creatorEmail: [String] = []

    var iconName: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// data management module
struct SubmitDataRecord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var userID: Int32 = 0

    var email: String = String()

    var campaignID: Int32 = 0

    var timestamp: Int64 = 0

    var dataSource: Int32 = 0

    var accuracy: Float = 0

    var value: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var success: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct SubmitDataRecords {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var userID: Int32 = 0

    var email: String = String()

    var campaignID: Int32 = 0

    var timestamp: [Int64] = []

    var dataSource: [Int32] = []

    var accuracy: [Float] = []

    var value: [Data] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var success: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct RetrieveKNextDataRecords {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var userID: Int32 = 0

    var email: String = String()

    var targetEmail: String = String()

    var targetCampaignID: Int32 = 0

    var targetDataSourceID: Int32 = 0

    var k: Int32 = 0

    var fromRecordID: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var success: Bool = false

    var id: [Int32] = []

    var timestamp: [Int64] = []

    var dataSource: [Int32] = []

    var value: [Data] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct RetrieveFilteredDataRecords {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var userID: Int32 = 0

    var email: String = String()

    var targetEmail: String = String()

    var targetCampaignID: Int32 = 0

    var targetDataSourceID: Int32 = 0

    var fromTimestamp: Int64 = 0

    var tillTimestamp: Int64 = 0

    var simplifyIfTooLarge: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var success: Bool = false

    var timestamp: [Int64] = []

    var dataSource: [Int32] = []

    var value: [Data] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct DownloadDumpfile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var userID: Int32 = 0

    var email: String = String()

    var campaignID: Int32 = 0

    var targetEmail: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var success: Bool = false

    var dump: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// statistics module
struct SubmitHeartbeat {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var userID: Int32 = 0

    var email: String = String()

    var campaignID: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var success: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// communication management module
struct SubmitDirectMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var userID: Int32 = 0

    var email: String = String()

    var targetEmail: String = String()

    var subject: String = String()

    var content: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var success: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct RetrieveUnreadDirectMessages {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var userID: Int32 = 0

    var email: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var success: Bool = false

    var sourceEmail: [String] = []

    var timestamp: [Int64] = []

    var subject: [String] = []

    var content: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct RetrieveUnreadNotifications {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var userID: Int32 = 0

    var email: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var success: Bool = false

    var notificationID: [Int32] = []

    var campaignID: [Int32] = []

    var timestamp: [Int64] = []

    var subject: [String] = []

    var content: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension LoginWithGoogle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LoginWithGoogle"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LoginWithGoogle, rhs: LoginWithGoogle) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LoginWithGoogle.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = LoginWithGoogle.protoMessageName + ".Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "idToken"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.idToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.idToken.isEmpty {
      try visitor.visitSingularStringField(value: self.idToken, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LoginWithGoogle.Request, rhs: LoginWithGoogle.Request) -> Bool {
    if lhs.idToken != rhs.idToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LoginWithGoogle.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = LoginWithGoogle.protoMessageName + ".Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "userId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.userID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt32Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LoginWithGoogle.Response, rhs: LoginWithGoogle.Response) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LoginDashboard: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LoginDashboard"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LoginDashboard, rhs: LoginDashboard) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LoginDashboard.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = LoginDashboard.protoMessageName + ".Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "email"),
    2: .same(proto: "name"),
    3: .same(proto: "dashboardKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.dashboardKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.dashboardKey.isEmpty {
      try visitor.visitSingularStringField(value: self.dashboardKey, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LoginDashboard.Request, rhs: LoginDashboard.Request) -> Bool {
    if lhs.email != rhs.email {return false}
    if lhs.name != rhs.name {return false}
    if lhs.dashboardKey != rhs.dashboardKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LoginDashboard.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = LoginDashboard.protoMessageName + ".Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "userId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.userID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt32Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LoginDashboard.Response, rhs: LoginDashboard.Response) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BindUserToCampaign: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BindUserToCampaign"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BindUserToCampaign, rhs: BindUserToCampaign) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BindUserToCampaign.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BindUserToCampaign.protoMessageName + ".Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "email"),
    3: .same(proto: "campaignId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.campaignID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt32Field(value: self.userID, fieldNumber: 1)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 2)
    }
    if self.campaignID != 0 {
      try visitor.visitSingularInt32Field(value: self.campaignID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BindUserToCampaign.Request, rhs: BindUserToCampaign.Request) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.email != rhs.email {return false}
    if lhs.campaignID != rhs.campaignID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BindUserToCampaign.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BindUserToCampaign.protoMessageName + ".Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "isFirstTimeBinding"),
    3: .same(proto: "campaignStartTimestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isFirstTimeBinding) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.campaignStartTimestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if self.isFirstTimeBinding != false {
      try visitor.visitSingularBoolField(value: self.isFirstTimeBinding, fieldNumber: 2)
    }
    if self.campaignStartTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.campaignStartTimestamp, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BindUserToCampaign.Response, rhs: BindUserToCampaign.Response) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.isFirstTimeBinding != rhs.isFirstTimeBinding {return false}
    if lhs.campaignStartTimestamp != rhs.campaignStartTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RetrieveParticipants: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RetrieveParticipants"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RetrieveParticipants, rhs: RetrieveParticipants) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RetrieveParticipants.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RetrieveParticipants.protoMessageName + ".Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "email"),
    3: .same(proto: "campaignId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.campaignID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt32Field(value: self.userID, fieldNumber: 1)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 2)
    }
    if self.campaignID != 0 {
      try visitor.visitSingularInt32Field(value: self.campaignID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RetrieveParticipants.Request, rhs: RetrieveParticipants.Request) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.email != rhs.email {return false}
    if lhs.campaignID != rhs.campaignID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RetrieveParticipants.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RetrieveParticipants.protoMessageName + ".Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "userId"),
    3: .same(proto: "email"),
    4: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeRepeatedInt32Field(value: &self.userID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.email) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.userID.isEmpty {
      try visitor.visitPackedInt32Field(value: self.userID, fieldNumber: 2)
    }
    if !self.email.isEmpty {
      try visitor.visitRepeatedStringField(value: self.email, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitRepeatedStringField(value: self.name, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RetrieveParticipants.Response, rhs: RetrieveParticipants.Response) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.email != rhs.email {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RetrieveParticipantStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RetrieveParticipantStats"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RetrieveParticipantStats, rhs: RetrieveParticipantStats) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RetrieveParticipantStats.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RetrieveParticipantStats.protoMessageName + ".Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "email"),
    3: .same(proto: "targetEmail"),
    4: .same(proto: "targetCampaignId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.targetEmail) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.targetCampaignID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt32Field(value: self.userID, fieldNumber: 1)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 2)
    }
    if !self.targetEmail.isEmpty {
      try visitor.visitSingularStringField(value: self.targetEmail, fieldNumber: 3)
    }
    if self.targetCampaignID != 0 {
      try visitor.visitSingularInt32Field(value: self.targetCampaignID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RetrieveParticipantStats.Request, rhs: RetrieveParticipantStats.Request) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.email != rhs.email {return false}
    if lhs.targetEmail != rhs.targetEmail {return false}
    if lhs.targetCampaignID != rhs.targetCampaignID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RetrieveParticipantStats.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RetrieveParticipantStats.protoMessageName + ".Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "activeCampaignId"),
    3: .same(proto: "campaignJoinTimestamp"),
    4: .same(proto: "lastSyncTimestamp"),
    5: .same(proto: "lastHeartbeatTimestamp"),
    6: .same(proto: "amountOfSubmittedDataSamples"),
    7: .same(proto: "dataSourceId"),
    8: .same(proto: "perDataSourceAmountOfData"),
    9: .same(proto: "perDataSourceLastSyncTimestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.activeCampaignID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.campaignJoinTimestamp) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.lastSyncTimestamp) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.lastHeartbeatTimestamp) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.amountOfSubmittedDataSamples) }()
      case 7: try { try decoder.decodeRepeatedInt32Field(value: &self.dataSourceID) }()
      case 8: try { try decoder.decodeRepeatedInt32Field(value: &self.perDataSourceAmountOfData) }()
      case 9: try { try decoder.decodeRepeatedInt64Field(value: &self.perDataSourceLastSyncTimestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if self.activeCampaignID != 0 {
      try visitor.visitSingularInt32Field(value: self.activeCampaignID, fieldNumber: 2)
    }
    if self.campaignJoinTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.campaignJoinTimestamp, fieldNumber: 3)
    }
    if self.lastSyncTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.lastSyncTimestamp, fieldNumber: 4)
    }
    if self.lastHeartbeatTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.lastHeartbeatTimestamp, fieldNumber: 5)
    }
    if self.amountOfSubmittedDataSamples != 0 {
      try visitor.visitSingularInt32Field(value: self.amountOfSubmittedDataSamples, fieldNumber: 6)
    }
    if !self.dataSourceID.isEmpty {
      try visitor.visitPackedInt32Field(value: self.dataSourceID, fieldNumber: 7)
    }
    if !self.perDataSourceAmountOfData.isEmpty {
      try visitor.visitPackedInt32Field(value: self.perDataSourceAmountOfData, fieldNumber: 8)
    }
    if !self.perDataSourceLastSyncTimestamp.isEmpty {
      try visitor.visitPackedInt64Field(value: self.perDataSourceLastSyncTimestamp, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RetrieveParticipantStats.Response, rhs: RetrieveParticipantStats.Response) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.activeCampaignID != rhs.activeCampaignID {return false}
    if lhs.campaignJoinTimestamp != rhs.campaignJoinTimestamp {return false}
    if lhs.lastSyncTimestamp != rhs.lastSyncTimestamp {return false}
    if lhs.lastHeartbeatTimestamp != rhs.lastHeartbeatTimestamp {return false}
    if lhs.amountOfSubmittedDataSamples != rhs.amountOfSubmittedDataSamples {return false}
    if lhs.dataSourceID != rhs.dataSourceID {return false}
    if lhs.perDataSourceAmountOfData != rhs.perDataSourceAmountOfData {return false}
    if lhs.perDataSourceLastSyncTimestamp != rhs.perDataSourceLastSyncTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RegisterCampaign: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RegisterCampaign"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RegisterCampaign, rhs: RegisterCampaign) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RegisterCampaign.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RegisterCampaign.protoMessageName + ".Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "email"),
    3: .same(proto: "campaignId"),
    4: .same(proto: "name"),
    5: .same(proto: "notes"),
    6: .same(proto: "configJson"),
    7: .same(proto: "startTimestamp"),
    8: .same(proto: "endTimestamp"),
    9: .same(proto: "removeInactiveUsersTimeout"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.campaignID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.notes) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.configJson) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.startTimestamp) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.endTimestamp) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.removeInactiveUsersTimeout) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt32Field(value: self.userID, fieldNumber: 1)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 2)
    }
    if self.campaignID != 0 {
      try visitor.visitSingularInt32Field(value: self.campaignID, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    if !self.notes.isEmpty {
      try visitor.visitSingularStringField(value: self.notes, fieldNumber: 5)
    }
    if !self.configJson.isEmpty {
      try visitor.visitSingularStringField(value: self.configJson, fieldNumber: 6)
    }
    if self.startTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.startTimestamp, fieldNumber: 7)
    }
    if self.endTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.endTimestamp, fieldNumber: 8)
    }
    if self.removeInactiveUsersTimeout != 0 {
      try visitor.visitSingularInt32Field(value: self.removeInactiveUsersTimeout, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RegisterCampaign.Request, rhs: RegisterCampaign.Request) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.email != rhs.email {return false}
    if lhs.campaignID != rhs.campaignID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.notes != rhs.notes {return false}
    if lhs.configJson != rhs.configJson {return false}
    if lhs.startTimestamp != rhs.startTimestamp {return false}
    if lhs.endTimestamp != rhs.endTimestamp {return false}
    if lhs.removeInactiveUsersTimeout != rhs.removeInactiveUsersTimeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RegisterCampaign.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RegisterCampaign.protoMessageName + ".Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "campaignId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.campaignID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if self.campaignID != 0 {
      try visitor.visitSingularInt32Field(value: self.campaignID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RegisterCampaign.Response, rhs: RegisterCampaign.Response) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.campaignID != rhs.campaignID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeleteCampaign: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DeleteCampaign"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DeleteCampaign, rhs: DeleteCampaign) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeleteCampaign.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DeleteCampaign.protoMessageName + ".Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "email"),
    3: .same(proto: "campaignId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.campaignID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt32Field(value: self.userID, fieldNumber: 1)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 2)
    }
    if self.campaignID != 0 {
      try visitor.visitSingularInt32Field(value: self.campaignID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DeleteCampaign.Request, rhs: DeleteCampaign.Request) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.email != rhs.email {return false}
    if lhs.campaignID != rhs.campaignID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeleteCampaign.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DeleteCampaign.protoMessageName + ".Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DeleteCampaign.Response, rhs: DeleteCampaign.Response) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RetrieveCampaigns: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RetrieveCampaigns"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RetrieveCampaigns, rhs: RetrieveCampaigns) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RetrieveCampaigns.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RetrieveCampaigns.protoMessageName + ".Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "email"),
    3: .same(proto: "myCampaignsOnly"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.myCampaignsOnly) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt32Field(value: self.userID, fieldNumber: 1)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 2)
    }
    if self.myCampaignsOnly != false {
      try visitor.visitSingularBoolField(value: self.myCampaignsOnly, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RetrieveCampaigns.Request, rhs: RetrieveCampaigns.Request) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.email != rhs.email {return false}
    if lhs.myCampaignsOnly != rhs.myCampaignsOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RetrieveCampaigns.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RetrieveCampaigns.protoMessageName + ".Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "campaignId"),
    3: .same(proto: "name"),
    4: .same(proto: "notes"),
    5: .same(proto: "startTimestamp"),
    6: .same(proto: "endTimestamp"),
    7: .same(proto: "removeInactiveUsersTimeout"),
    8: .same(proto: "creatorEmail"),
    9: .same(proto: "configJson"),
    10: .same(proto: "participantCount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeRepeatedInt32Field(value: &self.campaignID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.name) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.notes) }()
      case 5: try { try decoder.decodeRepeatedInt64Field(value: &self.startTimestamp) }()
      case 6: try { try decoder.decodeRepeatedInt64Field(value: &self.endTimestamp) }()
      case 7: try { try decoder.decodeRepeatedInt32Field(value: &self.removeInactiveUsersTimeout) }()
      case 8: try { try decoder.decodeRepeatedStringField(value: &self.creatorEmail) }()
      case 9: try { try decoder.decodeRepeatedStringField(value: &self.configJson) }()
      case 10: try { try decoder.decodeRepeatedInt32Field(value: &self.participantCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.campaignID.isEmpty {
      try visitor.visitPackedInt32Field(value: self.campaignID, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitRepeatedStringField(value: self.name, fieldNumber: 3)
    }
    if !self.notes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.notes, fieldNumber: 4)
    }
    if !self.startTimestamp.isEmpty {
      try visitor.visitPackedInt64Field(value: self.startTimestamp, fieldNumber: 5)
    }
    if !self.endTimestamp.isEmpty {
      try visitor.visitPackedInt64Field(value: self.endTimestamp, fieldNumber: 6)
    }
    if !self.removeInactiveUsersTimeout.isEmpty {
      try visitor.visitPackedInt32Field(value: self.removeInactiveUsersTimeout, fieldNumber: 7)
    }
    if !self.creatorEmail.isEmpty {
      try visitor.visitRepeatedStringField(value: self.creatorEmail, fieldNumber: 8)
    }
    if !self.configJson.isEmpty {
      try visitor.visitRepeatedStringField(value: self.configJson, fieldNumber: 9)
    }
    if !self.participantCount.isEmpty {
      try visitor.visitPackedInt32Field(value: self.participantCount, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RetrieveCampaigns.Response, rhs: RetrieveCampaigns.Response) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.campaignID != rhs.campaignID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.notes != rhs.notes {return false}
    if lhs.startTimestamp != rhs.startTimestamp {return false}
    if lhs.endTimestamp != rhs.endTimestamp {return false}
    if lhs.removeInactiveUsersTimeout != rhs.removeInactiveUsersTimeout {return false}
    if lhs.creatorEmail != rhs.creatorEmail {return false}
    if lhs.configJson != rhs.configJson {return false}
    if lhs.participantCount != rhs.participantCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RetrieveCampaign: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RetrieveCampaign"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RetrieveCampaign, rhs: RetrieveCampaign) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RetrieveCampaign.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RetrieveCampaign.protoMessageName + ".Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "email"),
    3: .same(proto: "campaignId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.campaignID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt32Field(value: self.userID, fieldNumber: 1)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 2)
    }
    if self.campaignID != 0 {
      try visitor.visitSingularInt32Field(value: self.campaignID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RetrieveCampaign.Request, rhs: RetrieveCampaign.Request) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.email != rhs.email {return false}
    if lhs.campaignID != rhs.campaignID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RetrieveCampaign.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RetrieveCampaign.protoMessageName + ".Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "name"),
    3: .same(proto: "notes"),
    4: .same(proto: "startTimestamp"),
    5: .same(proto: "endTimestamp"),
    6: .same(proto: "creatorEmail"),
    7: .same(proto: "configJson"),
    8: .same(proto: "participantCount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.notes) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.startTimestamp) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.endTimestamp) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.creatorEmail) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.configJson) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.participantCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.notes.isEmpty {
      try visitor.visitSingularStringField(value: self.notes, fieldNumber: 3)
    }
    if self.startTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.startTimestamp, fieldNumber: 4)
    }
    if self.endTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.endTimestamp, fieldNumber: 5)
    }
    if !self.creatorEmail.isEmpty {
      try visitor.visitSingularStringField(value: self.creatorEmail, fieldNumber: 6)
    }
    if !self.configJson.isEmpty {
      try visitor.visitSingularStringField(value: self.configJson, fieldNumber: 7)
    }
    if self.participantCount != 0 {
      try visitor.visitSingularInt32Field(value: self.participantCount, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RetrieveCampaign.Response, rhs: RetrieveCampaign.Response) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.name != rhs.name {return false}
    if lhs.notes != rhs.notes {return false}
    if lhs.startTimestamp != rhs.startTimestamp {return false}
    if lhs.endTimestamp != rhs.endTimestamp {return false}
    if lhs.creatorEmail != rhs.creatorEmail {return false}
    if lhs.configJson != rhs.configJson {return false}
    if lhs.participantCount != rhs.participantCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BindDataSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BindDataSource"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BindDataSource, rhs: BindDataSource) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BindDataSource.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BindDataSource.protoMessageName + ".Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "email"),
    3: .same(proto: "name"),
    4: .same(proto: "iconName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.iconName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt32Field(value: self.userID, fieldNumber: 1)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.iconName.isEmpty {
      try visitor.visitSingularStringField(value: self.iconName, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BindDataSource.Request, rhs: BindDataSource.Request) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.email != rhs.email {return false}
    if lhs.name != rhs.name {return false}
    if lhs.iconName != rhs.iconName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BindDataSource.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = BindDataSource.protoMessageName + ".Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "dataSourceId"),
    3: .same(proto: "iconName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.dataSourceID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.iconName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if self.dataSourceID != 0 {
      try visitor.visitSingularInt32Field(value: self.dataSourceID, fieldNumber: 2)
    }
    if !self.iconName.isEmpty {
      try visitor.visitSingularStringField(value: self.iconName, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BindDataSource.Response, rhs: BindDataSource.Response) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.dataSourceID != rhs.dataSourceID {return false}
    if lhs.iconName != rhs.iconName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RetrieveDataSources: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RetrieveDataSources"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RetrieveDataSources, rhs: RetrieveDataSources) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RetrieveDataSources.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RetrieveDataSources.protoMessageName + ".Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "email"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.email) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt32Field(value: self.userID, fieldNumber: 1)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RetrieveDataSources.Request, rhs: RetrieveDataSources.Request) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.email != rhs.email {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RetrieveDataSources.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RetrieveDataSources.protoMessageName + ".Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "dataSourceId"),
    3: .same(proto: "name"),
    4: .same(proto: "creatorEmail"),
    5: .same(proto: "iconName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeRepeatedInt32Field(value: &self.dataSourceID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.name) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.creatorEmail) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.iconName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.dataSourceID.isEmpty {
      try visitor.visitPackedInt32Field(value: self.dataSourceID, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitRepeatedStringField(value: self.name, fieldNumber: 3)
    }
    if !self.creatorEmail.isEmpty {
      try visitor.visitRepeatedStringField(value: self.creatorEmail, fieldNumber: 4)
    }
    if !self.iconName.isEmpty {
      try visitor.visitRepeatedStringField(value: self.iconName, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RetrieveDataSources.Response, rhs: RetrieveDataSources.Response) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.dataSourceID != rhs.dataSourceID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.creatorEmail != rhs.creatorEmail {return false}
    if lhs.iconName != rhs.iconName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubmitDataRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SubmitDataRecord"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SubmitDataRecord, rhs: SubmitDataRecord) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubmitDataRecord.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SubmitDataRecord.protoMessageName + ".Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "email"),
    3: .same(proto: "campaignId"),
    4: .same(proto: "timestamp"),
    5: .same(proto: "dataSource"),
    6: .same(proto: "accuracy"),
    7: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.campaignID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.dataSource) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.accuracy) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt32Field(value: self.userID, fieldNumber: 1)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 2)
    }
    if self.campaignID != 0 {
      try visitor.visitSingularInt32Field(value: self.campaignID, fieldNumber: 3)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 4)
    }
    if self.dataSource != 0 {
      try visitor.visitSingularInt32Field(value: self.dataSource, fieldNumber: 5)
    }
    if self.accuracy != 0 {
      try visitor.visitSingularFloatField(value: self.accuracy, fieldNumber: 6)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SubmitDataRecord.Request, rhs: SubmitDataRecord.Request) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.email != rhs.email {return false}
    if lhs.campaignID != rhs.campaignID {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.dataSource != rhs.dataSource {return false}
    if lhs.accuracy != rhs.accuracy {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubmitDataRecord.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SubmitDataRecord.protoMessageName + ".Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SubmitDataRecord.Response, rhs: SubmitDataRecord.Response) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubmitDataRecords: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SubmitDataRecords"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SubmitDataRecords, rhs: SubmitDataRecords) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubmitDataRecords.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SubmitDataRecords.protoMessageName + ".Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "email"),
    3: .same(proto: "campaignId"),
    4: .same(proto: "timestamp"),
    5: .same(proto: "dataSource"),
    6: .same(proto: "accuracy"),
    7: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.campaignID) }()
      case 4: try { try decoder.decodeRepeatedInt64Field(value: &self.timestamp) }()
      case 5: try { try decoder.decodeRepeatedInt32Field(value: &self.dataSource) }()
      case 6: try { try decoder.decodeRepeatedFloatField(value: &self.accuracy) }()
      case 7: try { try decoder.decodeRepeatedBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt32Field(value: self.userID, fieldNumber: 1)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 2)
    }
    if self.campaignID != 0 {
      try visitor.visitSingularInt32Field(value: self.campaignID, fieldNumber: 3)
    }
    if !self.timestamp.isEmpty {
      try visitor.visitPackedInt64Field(value: self.timestamp, fieldNumber: 4)
    }
    if !self.dataSource.isEmpty {
      try visitor.visitPackedInt32Field(value: self.dataSource, fieldNumber: 5)
    }
    if !self.accuracy.isEmpty {
      try visitor.visitPackedFloatField(value: self.accuracy, fieldNumber: 6)
    }
    if !self.value.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.value, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SubmitDataRecords.Request, rhs: SubmitDataRecords.Request) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.email != rhs.email {return false}
    if lhs.campaignID != rhs.campaignID {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.dataSource != rhs.dataSource {return false}
    if lhs.accuracy != rhs.accuracy {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubmitDataRecords.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SubmitDataRecords.protoMessageName + ".Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SubmitDataRecords.Response, rhs: SubmitDataRecords.Response) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RetrieveKNextDataRecords: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RetrieveKNextDataRecords"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RetrieveKNextDataRecords, rhs: RetrieveKNextDataRecords) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RetrieveKNextDataRecords.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RetrieveKNextDataRecords.protoMessageName + ".Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "email"),
    3: .same(proto: "targetEmail"),
    4: .same(proto: "targetCampaignId"),
    5: .same(proto: "targetDataSourceId"),
    6: .same(proto: "k"),
    7: .same(proto: "fromRecordId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.targetEmail) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.targetCampaignID) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.targetDataSourceID) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.k) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.fromRecordID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt32Field(value: self.userID, fieldNumber: 1)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 2)
    }
    if !self.targetEmail.isEmpty {
      try visitor.visitSingularStringField(value: self.targetEmail, fieldNumber: 3)
    }
    if self.targetCampaignID != 0 {
      try visitor.visitSingularInt32Field(value: self.targetCampaignID, fieldNumber: 4)
    }
    if self.targetDataSourceID != 0 {
      try visitor.visitSingularInt32Field(value: self.targetDataSourceID, fieldNumber: 5)
    }
    if self.k != 0 {
      try visitor.visitSingularInt32Field(value: self.k, fieldNumber: 6)
    }
    if self.fromRecordID != 0 {
      try visitor.visitSingularInt32Field(value: self.fromRecordID, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RetrieveKNextDataRecords.Request, rhs: RetrieveKNextDataRecords.Request) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.email != rhs.email {return false}
    if lhs.targetEmail != rhs.targetEmail {return false}
    if lhs.targetCampaignID != rhs.targetCampaignID {return false}
    if lhs.targetDataSourceID != rhs.targetDataSourceID {return false}
    if lhs.k != rhs.k {return false}
    if lhs.fromRecordID != rhs.fromRecordID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RetrieveKNextDataRecords.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RetrieveKNextDataRecords.protoMessageName + ".Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "id"),
    3: .same(proto: "timestamp"),
    4: .same(proto: "dataSource"),
    5: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeRepeatedInt32Field(value: &self.id) }()
      case 3: try { try decoder.decodeRepeatedInt64Field(value: &self.timestamp) }()
      case 4: try { try decoder.decodeRepeatedInt32Field(value: &self.dataSource) }()
      case 5: try { try decoder.decodeRepeatedBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitPackedInt32Field(value: self.id, fieldNumber: 2)
    }
    if !self.timestamp.isEmpty {
      try visitor.visitPackedInt64Field(value: self.timestamp, fieldNumber: 3)
    }
    if !self.dataSource.isEmpty {
      try visitor.visitPackedInt32Field(value: self.dataSource, fieldNumber: 4)
    }
    if !self.value.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.value, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RetrieveKNextDataRecords.Response, rhs: RetrieveKNextDataRecords.Response) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.id != rhs.id {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.dataSource != rhs.dataSource {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RetrieveFilteredDataRecords: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RetrieveFilteredDataRecords"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RetrieveFilteredDataRecords, rhs: RetrieveFilteredDataRecords) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RetrieveFilteredDataRecords.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RetrieveFilteredDataRecords.protoMessageName + ".Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "email"),
    3: .same(proto: "targetEmail"),
    4: .same(proto: "targetCampaignId"),
    5: .same(proto: "targetDataSourceId"),
    6: .same(proto: "fromTimestamp"),
    7: .same(proto: "tillTimestamp"),
    8: .same(proto: "simplifyIfTooLarge"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.targetEmail) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.targetCampaignID) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.targetDataSourceID) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.fromTimestamp) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.tillTimestamp) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.simplifyIfTooLarge) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt32Field(value: self.userID, fieldNumber: 1)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 2)
    }
    if !self.targetEmail.isEmpty {
      try visitor.visitSingularStringField(value: self.targetEmail, fieldNumber: 3)
    }
    if self.targetCampaignID != 0 {
      try visitor.visitSingularInt32Field(value: self.targetCampaignID, fieldNumber: 4)
    }
    if self.targetDataSourceID != 0 {
      try visitor.visitSingularInt32Field(value: self.targetDataSourceID, fieldNumber: 5)
    }
    if self.fromTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.fromTimestamp, fieldNumber: 6)
    }
    if self.tillTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.tillTimestamp, fieldNumber: 7)
    }
    if self.simplifyIfTooLarge != false {
      try visitor.visitSingularBoolField(value: self.simplifyIfTooLarge, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RetrieveFilteredDataRecords.Request, rhs: RetrieveFilteredDataRecords.Request) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.email != rhs.email {return false}
    if lhs.targetEmail != rhs.targetEmail {return false}
    if lhs.targetCampaignID != rhs.targetCampaignID {return false}
    if lhs.targetDataSourceID != rhs.targetDataSourceID {return false}
    if lhs.fromTimestamp != rhs.fromTimestamp {return false}
    if lhs.tillTimestamp != rhs.tillTimestamp {return false}
    if lhs.simplifyIfTooLarge != rhs.simplifyIfTooLarge {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RetrieveFilteredDataRecords.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RetrieveFilteredDataRecords.protoMessageName + ".Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "timestamp"),
    3: .same(proto: "dataSource"),
    4: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeRepeatedInt64Field(value: &self.timestamp) }()
      case 3: try { try decoder.decodeRepeatedInt32Field(value: &self.dataSource) }()
      case 4: try { try decoder.decodeRepeatedBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.timestamp.isEmpty {
      try visitor.visitPackedInt64Field(value: self.timestamp, fieldNumber: 2)
    }
    if !self.dataSource.isEmpty {
      try visitor.visitPackedInt32Field(value: self.dataSource, fieldNumber: 3)
    }
    if !self.value.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.value, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RetrieveFilteredDataRecords.Response, rhs: RetrieveFilteredDataRecords.Response) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.dataSource != rhs.dataSource {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DownloadDumpfile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DownloadDumpfile"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DownloadDumpfile, rhs: DownloadDumpfile) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DownloadDumpfile.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DownloadDumpfile.protoMessageName + ".Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "email"),
    3: .same(proto: "campaignId"),
    4: .same(proto: "targetEmail"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.campaignID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.targetEmail) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt32Field(value: self.userID, fieldNumber: 1)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 2)
    }
    if self.campaignID != 0 {
      try visitor.visitSingularInt32Field(value: self.campaignID, fieldNumber: 3)
    }
    if !self.targetEmail.isEmpty {
      try visitor.visitSingularStringField(value: self.targetEmail, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DownloadDumpfile.Request, rhs: DownloadDumpfile.Request) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.email != rhs.email {return false}
    if lhs.campaignID != rhs.campaignID {return false}
    if lhs.targetEmail != rhs.targetEmail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DownloadDumpfile.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DownloadDumpfile.protoMessageName + ".Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "dump"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.dump) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.dump.isEmpty {
      try visitor.visitSingularBytesField(value: self.dump, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DownloadDumpfile.Response, rhs: DownloadDumpfile.Response) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.dump != rhs.dump {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubmitHeartbeat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SubmitHeartbeat"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SubmitHeartbeat, rhs: SubmitHeartbeat) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubmitHeartbeat.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SubmitHeartbeat.protoMessageName + ".Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "email"),
    3: .same(proto: "campaignId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.campaignID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt32Field(value: self.userID, fieldNumber: 1)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 2)
    }
    if self.campaignID != 0 {
      try visitor.visitSingularInt32Field(value: self.campaignID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SubmitHeartbeat.Request, rhs: SubmitHeartbeat.Request) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.email != rhs.email {return false}
    if lhs.campaignID != rhs.campaignID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubmitHeartbeat.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SubmitHeartbeat.protoMessageName + ".Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SubmitHeartbeat.Response, rhs: SubmitHeartbeat.Response) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubmitDirectMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SubmitDirectMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SubmitDirectMessage, rhs: SubmitDirectMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubmitDirectMessage.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SubmitDirectMessage.protoMessageName + ".Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "email"),
    3: .same(proto: "targetEmail"),
    4: .same(proto: "subject"),
    5: .same(proto: "content"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.targetEmail) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.subject) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.content) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt32Field(value: self.userID, fieldNumber: 1)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 2)
    }
    if !self.targetEmail.isEmpty {
      try visitor.visitSingularStringField(value: self.targetEmail, fieldNumber: 3)
    }
    if !self.subject.isEmpty {
      try visitor.visitSingularStringField(value: self.subject, fieldNumber: 4)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SubmitDirectMessage.Request, rhs: SubmitDirectMessage.Request) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.email != rhs.email {return false}
    if lhs.targetEmail != rhs.targetEmail {return false}
    if lhs.subject != rhs.subject {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubmitDirectMessage.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SubmitDirectMessage.protoMessageName + ".Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SubmitDirectMessage.Response, rhs: SubmitDirectMessage.Response) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RetrieveUnreadDirectMessages: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RetrieveUnreadDirectMessages"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RetrieveUnreadDirectMessages, rhs: RetrieveUnreadDirectMessages) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RetrieveUnreadDirectMessages.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RetrieveUnreadDirectMessages.protoMessageName + ".Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "email"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.email) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt32Field(value: self.userID, fieldNumber: 1)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RetrieveUnreadDirectMessages.Request, rhs: RetrieveUnreadDirectMessages.Request) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.email != rhs.email {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RetrieveUnreadDirectMessages.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RetrieveUnreadDirectMessages.protoMessageName + ".Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "sourceEmail"),
    3: .same(proto: "timestamp"),
    4: .same(proto: "subject"),
    5: .same(proto: "content"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.sourceEmail) }()
      case 3: try { try decoder.decodeRepeatedInt64Field(value: &self.timestamp) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.subject) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.content) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.sourceEmail.isEmpty {
      try visitor.visitRepeatedStringField(value: self.sourceEmail, fieldNumber: 2)
    }
    if !self.timestamp.isEmpty {
      try visitor.visitPackedInt64Field(value: self.timestamp, fieldNumber: 3)
    }
    if !self.subject.isEmpty {
      try visitor.visitRepeatedStringField(value: self.subject, fieldNumber: 4)
    }
    if !self.content.isEmpty {
      try visitor.visitRepeatedStringField(value: self.content, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RetrieveUnreadDirectMessages.Response, rhs: RetrieveUnreadDirectMessages.Response) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.sourceEmail != rhs.sourceEmail {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.subject != rhs.subject {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RetrieveUnreadNotifications: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RetrieveUnreadNotifications"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RetrieveUnreadNotifications, rhs: RetrieveUnreadNotifications) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RetrieveUnreadNotifications.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RetrieveUnreadNotifications.protoMessageName + ".Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "email"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.email) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt32Field(value: self.userID, fieldNumber: 1)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RetrieveUnreadNotifications.Request, rhs: RetrieveUnreadNotifications.Request) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.email != rhs.email {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RetrieveUnreadNotifications.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RetrieveUnreadNotifications.protoMessageName + ".Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "notificationId"),
    3: .same(proto: "campaignId"),
    4: .same(proto: "timestamp"),
    5: .same(proto: "subject"),
    6: .same(proto: "content"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeRepeatedInt32Field(value: &self.notificationID) }()
      case 3: try { try decoder.decodeRepeatedInt32Field(value: &self.campaignID) }()
      case 4: try { try decoder.decodeRepeatedInt64Field(value: &self.timestamp) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.subject) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.content) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.notificationID.isEmpty {
      try visitor.visitPackedInt32Field(value: self.notificationID, fieldNumber: 2)
    }
    if !self.campaignID.isEmpty {
      try visitor.visitPackedInt32Field(value: self.campaignID, fieldNumber: 3)
    }
    if !self.timestamp.isEmpty {
      try visitor.visitPackedInt64Field(value: self.timestamp, fieldNumber: 4)
    }
    if !self.subject.isEmpty {
      try visitor.visitRepeatedStringField(value: self.subject, fieldNumber: 5)
    }
    if !self.content.isEmpty {
      try visitor.visitRepeatedStringField(value: self.content, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RetrieveUnreadNotifications.Response, rhs: RetrieveUnreadNotifications.Response) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.notificationID != rhs.notificationID {return false}
    if lhs.campaignID != rhs.campaignID {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.subject != rhs.subject {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
